/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

 /** \class NA60Shape
     \ingroup Roofit
    
     P.d.f implementing the Extended Crystal Ball line shape
 **/
    
#include "RooFit.h"
    
#include "Riostream.h"
#include "Riostream.h"
#include <math.h>
    
#include "NA60Shape.h"
#include "RooAbsReal.h"
#include "RooRealVar.h"
#include "RooMath.h"
#include "TMath.h"
    
#include "TError.h"
    
using namespace std;
    
ClassImp(NA60Shape)
    
Double_t NA60Shape::evaluateLoc(double x) const {
  Double_t t0 = 1;
  Double_t t = (x-m)/sigma;

  if (t < alpha) {
    t0=1+pow(p1*(alpha-t),p2-(p3*sqrt(alpha-t)));
  }
  else if (t > alpha2) {    
    t0=1+pow(p12*(t-alpha2),p22-(p32*sqrt(t-alpha2)));
  }else{
    t0=1;
  }
    return exp(-0.5*pow(t/t0,2));
}
    
////////////////////////////////////////////////////////////////////////////////
    
Double_t NA60Shape::ApproxErf(Double_t arg) const
{
  static const double erflim = 5.0;
  if( arg > erflim )
    return 1.0;
  if( arg < -erflim )
    return -1.0;
    
  return RooMath::erf(arg);
}
    
////////////////////////////////////////////////////////////////////////////////
    
NA60Shape::NA60Shape(const char *name, const char *title,
                             RooAbsReal& _m, RooAbsReal& _m0, RooAbsReal& _sigma,
                             RooAbsReal& _alpha, RooAbsReal& _p1, 
                             RooAbsReal& _p2, RooAbsReal& _p3, 
                             RooAbsReal& _alpha2, RooAbsReal& _p12, 
                             RooAbsReal& _p22, RooAbsReal& _p32) :
RooAbsPdf(name, title),
  m("m", "Dependent", this, _m),
  m0("m0", "M0", this, _m0),
  sigma("sigma", "Sigma", this, _sigma),
  alpha("alpha", "Alpha", this, _alpha),
  p1("p1", "P1", this, _p1),
  p2("p2", "P2", this, _p2),
  p3("p3", "P3", this, _p3),
  alpha2("alpha2", "Alpha2", this, _alpha2),
  p12("p12", "P12", this, _p12),
  p22("p22", "P22", this, _p22),
  p32("p32", "P32", this, _p32)
{
}
    
////////////////////////////////////////////////////////////////////////////////
    
NA60Shape::NA60Shape(const NA60Shape& other, const char* name) :
  RooAbsPdf(other, name), m("m", this, other.m), m0("m0", this, other.m0),
  sigma("sigma", this, other.sigma), alpha("alpha", this, other.alpha),
  p1("p1", this, other.p1), p2("p2", this, other.p2), p3("p3", this, other.p3),
  alpha2("alpha2", this, other.alpha2),
  p12("p12", this, other.p12), p22("p22", this, other.p22), p32("p32", this, other.p32)
{
}
    
////////////////////////////////////////////////////////////////////////////////
    
Double_t NA60Shape::evaluate() const {
  Double_t t0 = 1;
  Double_t t = (m-m0)/sigma;

  if (t < alpha) {
    t0=1+pow(p1*(alpha-t),p2-(p3*sqrt(alpha-t)));
  }
  else if (t > alpha2) {    
    t0=1+pow(p12*(t-alpha2),p22-(p32*sqrt(t-alpha2)));
  }else{
    t0=1;
  }
    return exp(-0.5*pow(t/t0,2));
}
    
////////////////////////////////////////////////////////////////////////////////
    
Int_t NA60Shape::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{
  if( matchArgs(allVars,analVars,m) )
    return 1 ;
    
  return 0;
}
    
////////////////////////////////////////////////////////////////////////////////
    
Double_t NA60Shape::analyticalIntegral(Int_t code, const char* rangeName) const
{
    
  static const double sqrtPiOver2 = 1.2533141373;
  static const double sqrt2 = 1.4142135624;

  R__ASSERT(code==1);
  double result = 0.0;

  double sig = fabs((Double_t)sigma);

  double tmin = (m.min(rangeName)-m0)/sig;
  double tmax = (m.max(rangeName)-m0)/sig;

  double t0=1.0;

  double xmin = tmin;
  double xmax = tmax;

//  if( tmin >= alpha && tmax < alpha2) {
    xmin=tmin/t0;
    xmax=tmax/t0;
//    result += t0*sig*sqrtPiOver2*(   ApproxErf(xmax/sqrt2) - ApproxErf(xmin/sqrt2) );
//  }
  double dt=0.01;
  int N = (int) (tmax-tmin)/dt;
  N++;
  double sum=0;
  double func[N];
  double h =(tmax-tmin)/(N-1);
  double mass=0;

  for (int i=0; i<N; i++){
                mass=tmin + (tmax-tmin)*i/(N-1);
                func[i]=evaluateLoc(mass);
                sum=sum+h*func[i];
  }
  double integral=h/2.*(func[0]+func[N-1])+sum;
  return integral;
}
    
////////////////////////////////////////////////////////////////////////////////
/// Advertise that we know the maximum of self for given (m0,alpha,n,sigma)
    
Int_t NA60Shape::getMaxVal(const RooArgSet& vars) const
{
  RooArgSet dummy ;
    
  if (matchArgs(vars,dummy,m)) {
    return 1 ;
  }
  return 0 ;
}
    
////////////////////////////////////////////////////////////////////////////////
    
Double_t NA60Shape::maxVal(Int_t code) const
{
  R__ASSERT(code==1) ;
    
  // The maximum value for given (m0,alpha,n,alpha2,n2,sigma)
  return 1.0 ;
}
